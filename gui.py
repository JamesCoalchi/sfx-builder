# This code was generated by AI using cli.py and packer.py.

import os
import sys
import base64
import tkinter as tk
from tkinter import filedialog, messagebox
import subprocess
import PyInstaller.__main__

class FilePackerApp:
    def __init__(self, root):
        self.root = root
        self.root.title("File Packer")
        self.root.geometry("550x500")
        
        self.files_to_pack = []
        self.run_after_unpack = None
        
        # Create UI elements
        tk.Label(root, text="Files to Pack:", font=("Arial", 12)).grid(row=0, column=0, sticky="w", padx=10, pady=5)
        
        self.files_listbox = tk.Listbox(root, width=70, height=10)
        self.files_listbox.grid(row=1, column=0, columnspan=3, padx=10, pady=5)
        
        tk.Button(root, text="Add Files", command=self.add_files).grid(row=2, column=0, padx=10, pady=5)
        tk.Button(root, text="Remove Selected", command=self.remove_selected).grid(row=2, column=1, padx=10, pady=5)
        
        tk.Label(root, text="File to Run After Unpacking (Optional):", font=("Arial", 12)).grid(row=3, column=0, columnspan=2, sticky="w", padx=10, pady=5)
        
        self.run_after_var = tk.StringVar()
        self.run_after_entry = tk.Entry(root, textvariable=self.run_after_var, width=70)
        self.run_after_entry.grid(row=4, column=0, columnspan=2, padx=10, pady=5)
        
        tk.Button(root, text="Select File", command=self.select_run_file).grid(row=4, column=2, padx=10, pady=5)
        
        tk.Label(root, text="Output Executable Name:", font=("Arial", 12)).grid(row=5, column=0, sticky="w", padx=10, pady=5)
        
        self.output_name_var = tk.StringVar(value="packed_files")
        self.output_name_entry = tk.Entry(root, textvariable=self.output_name_var, width=70)
        self.output_name_entry.grid(row=6, column=0, columnspan=2, padx=10, pady=5)
        
        # Status text
        self.status_var = tk.StringVar(value="Ready to pack files.")
        tk.Label(root, textvariable=self.status_var, font=("Arial", 10)).grid(row=7, column=0, columnspan=3, sticky="w", padx=10, pady=5)
        
        # Create button
        tk.Button(root, text="Pack Files", command=self.pack_files, bg="#4CAF50", fg="white", font=("Arial", 12, "bold"), width=20, height=2).grid(row=8, column=0, columnspan=3, padx=10, pady=20)
    
    def add_files(self):
        files = filedialog.askopenfilenames(title="Select Files to Pack")
        for file in files:
            if file not in self.files_to_pack:
                self.files_to_pack.append(file)
                self.files_listbox.insert(tk.END, os.path.basename(file))
        
        self.update_status()
    
    def remove_selected(self):
        selected_indices = self.files_listbox.curselection()
        for index in reversed(selected_indices):
            del self.files_to_pack[index]
            self.files_listbox.delete(index)
        
        self.update_status()
    
    def select_run_file(self):
        file = filedialog.askopenfilename(title="Select File to Run After Unpacking")
        if file:
            self.run_after_unpack = file
            self.run_after_var.set(os.path.basename(file))
    
    def update_status(self):
        if not self.files_to_pack:
            self.status_var.set("Ready to pack files. Please add files first.")
        else:
            self.status_var.set(f"Ready to pack {len(self.files_to_pack)} files.")
    
    def pack_files(self):
        if not self.files_to_pack:
            messagebox.showwarning("Warning", "No files selected to pack.")
            return
        
        output_name = self.output_name_var.get()
        if not output_name:
            messagebox.showwarning("Warning", "Please specify an output file name.")
            return
        
        self.status_var.set("Creating unpacker script...")
        self.root.update()
        
        # Create the unpacker script
        unpacker_script = self.create_unpacker_script()
        
        with open("temp_unpacker.py", "w") as f:
            f.write(unpacker_script)
        
        self.status_var.set("Building executable...")
        self.root.update()
        
        # Use PyInstaller to create the executable
        try:
            PyInstaller.__main__.run([
                'temp_unpacker.py',
                '--onefile',
                '--name=' + output_name,
                '--clean'
            ])
            
            # Remove temporary file
            os.remove("temp_unpacker.py")
            
            self.status_var.set(f"Success! Executable created: {output_name}.exe")
            messagebox.showinfo("Success", f"Executable created successfully: {output_name}.exe\nLocation: {os.path.join(os.getcwd(), 'dist', output_name + '.exe')}")
        except Exception as e:
            self.status_var.set(f"Error: {str(e)}")
            messagebox.showerror("Error", f"Failed to create executable: {str(e)}")
    
    def create_unpacker_script(self):
        # Prepare data to embed in the unpacker script
        file_data = []
        
        for file_path in self.files_to_pack:
            with open(file_path, "rb") as f:
                content = f.read()
                encoded = base64.b64encode(content).decode('utf-8')
                file_data.append({
                    'name': os.path.basename(file_path),
                    'content': encoded
                })
        
        run_after_name = ""
        if self.run_after_unpack:
            run_after_name = os.path.basename(self.run_after_unpack)
        
        # Create the unpacker script
        script = """
import os
import sys
import base64
import subprocess
import tempfile
import shutil
import tkinter as tk
from tkinter import messagebox

# Embedded file data
FILE_DATA = {0}

# File to run after unpacking
RUN_AFTER = "{1}"

def unpack_files():
    # Create temporary directory for extraction
    extract_dir = os.path.join(os.getcwd(), "unpacked_files")
    
    # Create directory if it doesn't exist
    if not os.path.exists(extract_dir):
        os.makedirs(extract_dir)
    
    # Unpack files
    for file_info in FILE_DATA:
        file_path = os.path.join(extract_dir, file_info['name'])
        with open(file_path, 'wb') as f:
            content = base64.b64decode(file_info['content'])
            f.write(content)
    
    return extract_dir

def main():
    # Create simple UI
    root = tk.Tk()
    root.withdraw()  # Hide the main window
    
    try:
        # Unpack files
        extract_dir = unpack_files()
        
        # Show success message
        messagebox.showinfo(
            "Extraction Complete", 
            f"Files successfully unpacked to:\\n{{extract_dir}}"
        )
        
        # Run specified file if needed
        if RUN_AFTER:
            file_to_run = os.path.join(extract_dir, RUN_AFTER)
            if os.path.exists(file_to_run):
                # Determine how to run the file based on extension
                ext = os.path.splitext(file_to_run)[1].lower()
                
                if ext == '.py':
                    subprocess.Popen(['python', file_to_run], cwd=extract_dir)
                elif ext in ['.exe', '.bat', '.cmd']:
                    subprocess.Popen([file_to_run], cwd=extract_dir)
                else:
                    # For other file types, try to open with default application
                    if sys.platform == 'win32':
                        os.startfile(file_to_run)
                    elif sys.platform == 'darwin':  # macOS
                        subprocess.Popen(['open', file_to_run])
                    else:  # Linux
                        subprocess.Popen(['xdg-open', file_to_run])
    except Exception as e:
        messagebox.showerror("Error", f"An error occurred: {{str(e)}}")
    
    root.destroy()

if __name__ == "__main__":
    main()
""".format(file_data, run_after_name)
        
        return script

if __name__ == "__main__":
    root = tk.Tk()
    app = FilePackerApp(root)
    root.mainloop()